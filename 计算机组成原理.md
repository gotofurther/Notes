## 计算机组成原理

---

记录课程：
【王道计算机考研 计算机组成原理】 https://www.bilibili.com/video/BV1ps4y1d73V/?p=3&share_source=copy_web&vd_source=96efd9f8bc51a1cb14bac217120879dd
#### 一. 概况

**1.1 计算机硬件发展历程：**

   1. 第一代：电子管 1946-1957
      * 第一台**电子数字**计算机：ENIAC
      * 使用机器语言： 即电信号
      * 占地面积大
      * 功耗大
   2. 第二代：晶体管 1958-1964
      * 第一台使用晶体管线路的计算机：TRADIC
      * 面向过程的程序设计语言： FORTRAN
      * 有了操作系统的原型：需要机器自动管理底层硬件的功能
      * 耗电量与占地面积较上一代减少
   3. 第三代：中小规模集成电路 1964-1971
      * 高级语言迅速发展
      * 开始有了分时操作系统
      * 耗电量与占地面积较上一代减少
   4. 第四代：大规模、超大规模集成电路 1972-至今
      * 产生了微处理器
      * 产生了许多新的概念：并行、流水线、高速缓存、虚拟内存……

      摩尔定律：集成电路上的晶体管数量每18月就会翻一翻，所以每18月计算机的处理效率就会提高一倍。

      > 微型计算机的发展以微处理器技术为标志
      > 微处理器的发展以微处理器的机器字长(区别于操作系统位数)为标准

   * 机器字长：计算机一次整数运算所能处理的二进制位数，一定程度上决定了微处理器的运算速度(我们平时听到的多少位的处理器，这个多少位就是机器字长)
   * 操作系统位数：其所依赖指令集的位数，影响整个系统能够访问的存储空间的大小

**1.2 计算机分类与发展方向：**

   * 单指令流&单数据流（SISD）：冯诺依曼体系结构
   ![1737167052668](image/计算机组成原理/1737167052668.png)
   * 单指令流&多数据流（SIMD）：阵列处理器、向量处理器
   ![1737189359730](image/计算机组成原理/1737189359730.png)
   * 多数据流&单指令流（MISD）：实际上不存在
   * 多数据流&多指令流（MIMD）：多处理器
   ![1737167099278](image/计算机组成原理/1737167099278.png)

**1.3 计算机系统的组成**
   >美籍匈牙利科学家冯・诺依曼最先提出“程序存储”的思想，并成功将其运用在计算机的设计之中，根据这一原理制造的计算机被称为冯・诺依曼结构计算机。由于他对现代计算机技术的突出贡献，因此冯・诺依曼又被称为“现代计算机之父”。
   
   冯诺曼体系结构特点:
   * 计算机硬件系统由五大部件组成(存储器、运算器、控制器、输出设备、输入设备)
   * 指令和数据以同等地位存于存储器，可按地址寻访
   * 指令和数据用二进制表示
   * 指令由操作码和地址码组成
   * 存储程序
   * 以运算器为中心
   > 早期的冯・诺依曼机以运算器为中心，且是单处理机，最根本的特征是采用“存储程序”原理，基本工作方式是控制流驱动方式！
   ![1737275617440](image/计算机组成原理/1737275617440.png)

   现代计算机的组织结构:
   ![1737189380379](image/计算机组成原理/1737189380379.png)
   相较于冯诺曼体系结构，现代计算机的组织结构将存储器放在了中间，因为事先存储器需要输入一些数据与步骤给控制器，例如如何进行计算等，以及之后控制器与存储器进行数据交流时，运算器需要稍微暂停一下帮助存储器把这些数据搬过去，占用了其计算资源，故将存储器放在中心以方便运算器进行计算

   软件与硬件逻辑上是等效(但不等价)的
   >例如：可以通过增加运算器来实现更多位的计算(硬件层面)，也可以通过将运算切片来实现更多位的计算(软件层面)，故两个层面都可以实现其功能，是等效的，当是实现后运算效果是不一样的，故不能说是等价的。

   各部分硬件示意：
   ![1737193696047](image/计算机组成原理/1737193696047.png)

   由于运算器与控制器结构类似，联系紧密实际设计的时候会做成一块芯片即CPU，加上存储器后就可以正常工作了，由此于计算机组成将这三者的组合称为主机
   ![1737191179924](image/计算机组成原理/1737191179924.png)
   输入设备于输出设备称之为I/O设备，加上辅助存储器可以实现更加多样的功能，将这些除了组成主机外的设备称为外设
   ![1737191211831](image/计算机组成原理/1737191211831.png)

**1.4 CPU及运算过程**
   1. 运算器组成：
      ![1737191752018](image/计算机组成原理/1737191752018.png)
      * ALU(Arithmetic and Logic Unit算数逻辑单元，核心部件)：进行算数与逻辑运算，主要采用组合逻辑的设计方式(依据类似于1+1=2这样的计算规则看到输入直接得出输出)
      * MQ(Multiple-Quotient Register乘商寄存器)：进行乘除法时用到
      * ACC(Accumulator累加计数器)：存放操作数，运算的结果
      * X(通用寄存器，通用寄存器有很多个，X表示使用的是其中某一个)：存放操作数
      其上三个功能部件主要存放一些运算中间结果
      ![1737192918394](image/计算机组成原理/1737192918394.png)
      * PSW(Program Status Word程序状态字计算器)：存放一些状态，如有没有溢出，借位与进位等，在有的计算机系统中也称为FR(Flag Register标志寄存器)
   2. 控制器组成：
   ![1737192975321](image/计算机组成原理/1737192975321.png)
      * CU(Control Unit控制单元)：主要采用时序逻辑的设计方式(可以简单记录下当前步骤产生的一些结果，再根据这一结果判断下一步应该做什么)
      * IR(Instruction Register指令寄存器)：存放当前要执行的这条指令
      * PC(Program Counter程序计数器)：存放下一条要执行的指令的地址
   3. 取数指令示意：
   ![1737194212760](image/计算机组成原理/1737194212760.png)

**1.5 存储器**
   1. 存储器构造：
   ![1737251575216](image/计算机组成原理/1737251575216.png)
   * MAR(Memory Address Register地址寄存器)：用于指明要读写哪个存储单元，其位数反应存储单元数量
   * MDR(Memory Data Register数据寄存器)：用于暂存要从存储器读或写的信息，其位数=存储字长
   2. 存储体功能实现：
      1. 存储元：
      ![1737252070315](image/计算机组成原理/1737252070315.png)
      由一个电容与开光器件组成
         1. 读：
            给予开关器件一个电信号(可以为1也可以为0，具体取决于开关器件由1闭合还是0闭合)，开关器件闭合，导线输出端点电信号与电容电压相同(同一条导线电压相等)，由此可以读出电位高低
         2. 写：
            给予开关器件一个电信号，开关器件闭合，由导线输出端施加一个电信号，电容充放电实现电压变化，改变存储元电压
      2. 存储单元：
      ![1737252621988](image/计算机组成原理/1737252621988.png)
      由多个存储体组成存储单元，当于红色总线上施加一个电信号，即可读出对应存储单元中的数据，一口气读出来的这么多位的数据我们称为一个存储字，存储字有多少位我们称为存储字长
      3. 存储体：
      ![1737252706340](image/计算机组成原理/1737252706340.png)
      多个存储单元组成存储体，于对应行输入电信号闭合开关器件，即可读出这一行的存储字，但是其他行的开关器件不能闭合
      4. 译码器：
      由于我们输入的地址不可能是只包含一个1(开关器件闭合信号)，其他全为0的数据，故先通过译码器，后转换为对应的那一行数据的电信号使之为1其他为0
      ![1737253165403](image/计算机组成原理/1737253165403.png)
      $n位地址对应2^n个存储单元$

**1.6 小结**
   ![1737192292845](image/计算机组成原理/1737192292845.png)
   1. 性能指标：容量
      * 总容量 = 存储单元个数 × 存储字长 bit = 存储单元个数 × 存储字长/8 Byte
      ![1737276073795](image/计算机组成原理/1737276073795.png)
   2. 性能指标：速度
      * CPI(Clock cycle Per Instruction)：执行一条指令所需要的时钟周期
      整个程序耗时(CPU执行时间) = 指令1耗时 + 指令2耗时 + …… + 指令n耗时 
      = (指令1的CPI + 指令2的CPI + …… + 指令n的CPI) × CPU时钟周期
      = 平均CPI × 指令条数 × CPU时钟周期
      ![1737276502517](image/计算机组成原理/1737276502517.png)
      ![1737276723892](image/计算机组成原理/1737276723892.png)
      ![1737276786444](image/计算机组成原理/1737276786444.png)

**1.7 软件系统**
   1. 计算机软件系统：
   ![1737209967386](image/计算机组成原理/1737209967386.png)
   2. 计算机编程语言：
   ![1737210018221](image/计算机组成原理/1737210018221.png)
      * 编译：由高级语言转换到低级语言
      * 汇编：由汇编语言转换到机器语言
      * 编译程序：将程序代码全部解释为机器语言(计算机可以直接执行)的文件，这个文件会被保持下来，若没有修改源代码，可以直接执行这个文件，若修改过了需要重新编译一下
      * 解释程序：执行时每一句立即翻译为机器语言，下一次执行同样一句话的时候，无法知道前面是否执行过，故需要当场重新解释一遍

**1.8 计算机层次结构**
   ![1737210963539](image/计算机组成原理/1737210963539.png)

------
#### 二. 数运算
   **1. 进制**
   * 不同进制表示每一位上能为我们提供符号的多少，例如2进制每一位可以为我们提供两种符号(0,1)，10进制每一位上可以为我们提供10种符号(0,1,2,3,4,5,6,7,8,9)
      由此引出基数的概念
      > 基数：每个数位所用到的不同符号的多少
      
      一般来说基数大的进制表示数的位数少，但是数运算所遇情况多(例如10进制乘法需要考虑100种情况，0×0,0×1,0×2……)，而基数小的进制表示数所需位数多，但是数运算所遇情况少(例如2进制乘法需要考虑四种情况，0×0,0×1,1×0,1×1)
   ![1737278748730](image/计算机组成原理/1737278748730.png)
   * 进制转换：
      * 整数部分：
   ![1737278882994](image/计算机组成原理/1737278882994.png)
         > 每除一次，模下来的数就是对应那一位的数
      
      * 小数部分：
   ![1737292568623](image/计算机组成原理/1737292568623.png)
         > 每乘一次，乘的时候若大于1则表示这一位存在

   **2. 编码**

   * 字符的存储：
      ASCII码
   ![1737293982135](image/计算机组成原理/1737293982135.png)
   * 字符串的存储：
   ![1737293803146](image/计算机组成原理/1737293803146.png)

   **3. 校验**
   * 奇偶校验码：
   * 海明码：
   ![1737298694577](image/计算机组成原理/1737298694577.png)
   ![1737298725257](image/计算机组成原理/1737298725257.png)
   ![1737298761348](image/计算机组成原理/1737298761348.png)
   海明码只能检验一位错误，是偶校验的一种拓展
      * 几个疑问：
         * 数据怎么分组，为什么这样分组？
            $H_7 H_6 …… H_1$对应的下标可以表示为2进制，若对应下标m二进制的第k位不为0，即将m拆解后有$a_n * 2^n + a_{n-1} * 2^{n-1} + … + a_0 * 2^0$(k可为0或1)，其中某项$a_k * 2^k$不为0，则这一项属于第k组，**如此分组是为了让每个校验位能够覆盖到特定的数据位，从而实现对这些数据位的校验。每个校验位都负责一组数据位的校验，通过计算这组数据位的异或值来确定校验位的值。当数据位出错时，相应的校验位将不再满足奇偶校验条件，从而可以定位到出错的数据位。**
         * 为什么检验位在$2^k$？
         这样的放置方式可以确保每个数据位都被至少一个校验位所覆盖，并且每个校验位都**能够独立地校验一组数据位**。这种分布方式使得海明码能够高效地检测并纠正错误。
         * 检验位的个数是几个？公式$2^k=k + n + 1$是怎么来的？
         海明码至少要能检验出n+k个1位出错情况(包括所有可能的数据位和校验位出错的情况)，以及不出错的情况，共n+k+1种情况。
         而k位校验位能检测出$2^k$种不同的错误情况(因为每位校验位可以是0或1，共有$2^k$种组合)。
         所以要满足$2^k >= n + k + 1$，以确保有足够的校验位来覆盖所有可能的错误情况。
         * 如何检验错误？
         ![1737375593161](image/计算机组成原理/1737375593161.png)
         例如5号位由0变成1，已知5号位所在的分组为1，3，无法通过偶校验使之为1，分组2可以通过为0，则最后为101对应5的二进制码
   * 循环冗余校验码CRC码：
   ![1737376136797](image/计算机组成原理/1737376136797.png)
   ![1737376233447](image/计算机组成原理/1737376233447.png)
   ![1737376291401](image/计算机组成原理/1737376291401.png)

   * 定点数的编码：
      * 原码：

      * 反码：
      
      * 补码：
         * 方便加法运算，减少硬件成本(无需设计减法器)
         * 正数原、反、补码相同，负数原码除了符号位其他全部取反为反码，再加1为补码
         * 补码原理：
            例如在时钟上将十点拨到七点，可以10+(-3)，也可以10+9，由于计算机中实现加法会比实现减法方便，故由此设计补码以实现将加法转为减法的操作
         ![1737444930239](image/计算机组成原理/1737444930239.png)
      * 移码：
         * 补码符号位由0变1，由1变0，方便比较大小
         ![1737445542063](image/计算机组成原理/1737445542063.png)
      
      * (扩展)C语言中的强制类型转换：
         ![1737445993537](image/计算机组成原理/1737445993537.png)

         * 数据扩展
            * 为什么扩展：
            
               * ALU(累加计数器)的位数是固定的，运算前可能需要把短数据扩展为长数据
               * 通用寄存器的位数是固定的，把数据存入寄存器，可能需要进行长度扩展
               * 主存内的各种数据长度不一，有时需要把短数据扩展为长数据
            
            * 零扩展：
               无符号数 90： 01011010     ----->**00000000**01011010
               无符号数 166：10100110     ----->**00000000**10100110 
               >适应于无符号整数，用0扩展高位
            * 符号扩展：
               带符号整数(补码) 90： 01011010----->0**00000000**1011010
               带符号整数(补码) -90：10100110----->1**11111111**0100110
               >适用于带符号整数(补码)，用“符号位”扩展高位
   * 数字逻辑        
      * 逻辑门电路： 
         ![1737447478801](image/计算机组成原理/1737447478801.png)
      * 加法器：
      ![1737448420836](image/计算机组成原理/1737448420836.png)
      ![1737448475655](image/计算机组成原理/1737448475655.png)
         * 串行加法器：
         将n个一位全加器串起来
         ![1737449321885](image/计算机组成原理/1737449321885.png)
         * 标志位：
         ![1737449243220](image/计算机组成原理/1737449243220.png)
         ![1737449093439](image/计算机组成原理/1737449093439.png)
         * 并行进位加法器：
         ![1737449840770](image/计算机组成原理/1737449840770.png)
         ![1737449910086](image/计算机组成原理/1737449910086.png)
      * ALU(算数逻辑单元)：
      ![1737468420698](image/计算机组成原理/1737468420698.png)
      ![1737468639458](image/计算机组成原理/1737468639458.png)
      ![1737468736638](image/计算机组成原理/1737468736638.png)
      ![1737468868096](image/计算机组成原理/1737468868096.png)
      * 定点数的运算：
         * 移位运算：
         ![1737472079193](image/计算机组成原理/1737472079193.png)
         * 加减运算：
            * 原码：
            ![1737511980659](image/计算机组成原理/1737511980659.png)
            * 补码：
            ![1737512347770](image/计算机组成原理/1737512347770.png)
               * 溢出判断：
                  * 方法一：
                  只有“正数+正数”才会出现上溢------正+正=负
                  只有“负数+负数”才会出现下溢------负+负=正
                  ![1737512773391](image/计算机组成原理/1737512773391.png)
                  * 方法二：
                  ![1737513162547](image/计算机组成原理/1737513162547.png)
                  * 方法三：
                  ![1737513239732](image/计算机组成原理/1737513239732.png)
                     >更高的符号位表示本来应该得到的正确的正负性
                     第二高的符号位表示实际运算的正负性
                     若两符号位相等则表示运算符号正确，反之发生溢出

                     * 双符号位补码又称为：模4补码(实际存储时只存一个符号位，运算时会复制一个符号位，故不占存储空间)
                     * 单符号位补码又称为：模2补码
         * 小结：
         ![1737513623497](image/计算机组成原理/1737513623497.png)

      * 无符号数的加减运算：
      ![1737515274621](image/计算机组成原理/1737515274621.png)
      * 实现补码加减运算的电路：
      ![1737515600546](image/计算机组成原理/1737515600546.png)
         >该电路也可以用于计算无符号数的加减运算

         ![1737515929227](image/计算机组成原理/1737515929227.png)
         ![1737552361103](image/计算机组成原理/1737552361103.png)
      * 乘法运算：
         * 原码：
         ![1737556466263](image/计算机组成原理/1737556466263.png)
         ![1737556438294](image/计算机组成原理/1737556438294.png)
         * 补码：
         ![1737556655933](image/计算机组成原理/1737556655933.png)
         ![1737557564707](image/计算机组成原理/1737557564707.png)
         ![1737557478838](image/计算机组成原理/1737557478838.png)












附录：
$2^{10}:K$ ; $2^{20}:M$ ; $2^{30}:G$ ; $2^{40}:T$